# InnoDB
/*
    InnoDB

        1.InnoDB 是 MySQL 默认的事务型存储引擎，只要在需要它不支持的特性时，才考虑使用其他存储引擎。

        2.InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。
          其默认级别时可重复读（REPEATABLE READ），在可重复读级别下，通过 MVCC(快照读情况) + Next-Key Locking(当前读情况) 防止幻读。

          Next-Key(行锁和gap锁)
            针对当前读的情况，mysql是通过Next-Key锁搞定的。就是在当前读的情况下，会加入一个范围锁，锁住一个区间，
            区间内如果有别的事务进行插入操作，是要等待当前事务提交的。

        3.主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对主键查询有很高的性能

            聚簇索引:
                聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。

        4.InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读，能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引，
          以及能够加速插入操作的插入缓冲区等。

        5.InnoDB 支持真正的在线热备份，MySQL 其他的存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合的场景中，
          停止写入可能也意味着停止读取。

 */

# MyISAM
/*
    MyISAM

        1.设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

        2.提供了大量的特性，包括压缩表、空间数据索引等。

        3.不支持事务。

        4.不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。
          但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

            共享锁(S锁):共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。
                如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。
            排它锁(X锁):用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。
                如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

        5.可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

        6.如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，
          只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，
          但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。


 */

# InnoDB 和 MyISAM 比较
/*
    1.事务: InnoDB 是事务类型的，可以使用Commit 和 Rollback 语句。

    2.并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。

    3.外键: InnoDB 支持外键。

    4.备份: InnoDB 支持在线热备份。

    5.崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。

    6.其它特性: MyISAM 支持压缩表和空间数据索引。

 */





